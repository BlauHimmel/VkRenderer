#pragma once

#ifndef GLFW_INCLUDE_VULKAN
#define GLFW_INCLUDE_VULKAN
#endif
#include <GLFW/glfw3.h>

/**
* The perspective projection matrix generated by GLM will use the OpenGL
* depth range of -1.0 to 1.0 by default. We need to configure it to use
* the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE
* definition.
*/
#ifndef GLM_FORCE_RADIANS
#define GLM_FORCE_RADIANS
#endif
#ifndef GLM_FORCE_DEPTH_ZERO_TO_ONE
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#endif
#include <glm/glm.hpp>

#include <cstdint>
#include <string>
#include <vector>
#include <array>
#include <optional>
#include <unordered_map>

#include "Namespace.hpp"
#include "Camera.hpp"

//TODO :
//    1. Update the vertex/index buffer while the app is running.
//    2. Update the texture while the app is running.
//    3. Add UI.
//    4. Add lighting.
//    5. PBR material.
//    6. Use environment map.
//    7. Implement IBR.
//    8. Pipeline cached.

NAMESPACE_BEGIN(GLOBAL_NAMESPACE)

/** An very simple vulkan application. */
class App
{
public:
	void Run();

protected:
	/** App */void InitWindow();
	/** App */void InitVulkan();
	/** App */void MainLoop();
	/** App */void Draw();
	/** App */void Destroy();

protected:
	/** App Helper */void UpdateUniformBuffer(
		uint32_t CurrentImage
	);

	/** Recreate the swapchain and all the objects depend on it. Called when resizing. */
	/** App Helper */void RecreateSwapChainAndRelevantObject();

	/** Destroy the objects that are to be recreated in the RecreateSwapChain(). Called when resizing. */
	/** App Helper */void DestroySwapChainAndRelevantObject();

	/** Recreate the drawing command buffer. Called when display mode or cull mode is changed. */
	/** App Helper */void RecreateDrawingCommandBuffer();

protected:
	/** Vulkan Init */void CreateInstance();

	/** Vulkan Init */void SetupDebugMessenger();

	/** Vulkan Init */void CreateSurface();

	/** Vulkan Init */void SelectPhysicalDevice();

	/** Vulkan Init */void CreateLogicalDevice();

	/** Vulkan Init */void CreateSwapChain();

	/** Vulkan Init */void CreateSwapChainImageViews();

	/** Vulkan Init */void CreateRenderPass();

	/** Vulkan Init */void CreateDescriptorSetLayout();

	/** Vulkan Init */void CreateGraphicsPipeline();

	/** Vulkan Init */void CreateCommandPool();

	/** Vulkan Init */void CreateColorResource();

	/** Vulkan Init */void CreateDepthResource();

	/** Vulkan Init */void CreateFramebuffers();

	/** Vulkan Init */void CreateTextureImage();

	/** Vulkan Init */void CreateTextureImageView();

	/** Vulkan Init */void CreateTextureSampler();

	/** Vulkan Init */void LoadObjModel();

	/** Vulkan Init */void CreateVertexBuffer();

	/** Vulkan Init */void CreateIndexBuffer();

	/** Vulkan Init */void CreateMvpUniformBuffer();

	/** Vulkan Init */void CreateLightUniformBuffer();

	/** Vulkan Init */void CreateDescriptorPool();

	/** Vulkan Init */void CreateDescriptorSets();

	/** Vulkan Init */void CreateDrawingCommandBuffers();

	/** Vulkan Init */void CreateSyncObjects();

protected:
	/** Callback */static VKAPI_ATTR VkBool32 VKAPI_CALL DebugCallback(
		VkDebugUtilsMessageSeverityFlagBitsEXT MessageSeverity,
		VkDebugUtilsMessageTypeFlagsEXT MessageType,
		const VkDebugUtilsMessengerCallbackDataEXT * pCallbackData,
		void * pUserData
	);

	/** Callback */static void FramebufferResizeCallback(
		GLFWwindow * pWindow,
		int Width,
		int Height
	);

	/** Callback */static void MouseButtonCallback(
		GLFWwindow* pWindow,
		int Button,
		int Action,
		int Mods
	);

	/** Callback */static void MousePositionCallback(
		GLFWwindow* pWindow,
		double X,
		double Y
	);

	/** Callback */static void MouseScrollCallback(
		GLFWwindow* pWindow,
		double OffsetX,
		double OffsetY
	);

	/** Callback */static void KeyboardCallback(
		GLFWwindow * pWindow, 
		int Key,
		int ScanCode,
		int Action,
		int Mods
	);

	/** Helper */static std::vector<char> ReadFile(
		const std::string & Filename
	);

protected: /** App */
	GLFWwindow * m_pWindow = nullptr;
	uint32_t m_InitWidth = 800;
	uint32_t m_InitHeight = 600;
	std::string m_Title = "Vulkan";
	std::string m_AppName = "VulkanApp";
	std::string m_EngineName = "VulkanEngine";
	std::string m_GpuName = "";
	bool m_bFramebufferResized = false;
	double m_FPS = 0.0f;

protected: /** Vulkan pipeline */
#ifdef NDEBUG
		const bool m_bEnableValidationLayers = false;
#else
		const bool m_bEnableValidationLayers = true;
#endif
	const std::vector<const char *> m_ValidationLayers =
	{
		"VK_LAYER_LUNARG_standard_validation"
	};

	const std::vector<const char *> m_DeviceExtensions =
	{
		VK_KHR_SWAPCHAIN_EXTENSION_NAME
	};

	const std::string m_VertexShaderPath = "Shaders/Shader.vert.spv";
	const std::string m_FragmentShaderPath = "Shaders/Shader.frag.spv";

	VkDebugUtilsMessengerEXT m_DebugMessenger = VK_NULL_HANDLE;
	VkSurfaceKHR m_Surface = VK_NULL_HANDLE;

	VkInstance m_Instance = VK_NULL_HANDLE;
	/** This object will be implicitly destroyed when the VkInstance is destroyed */
	VkPhysicalDevice m_PhysicalDevice = VK_NULL_HANDLE;

	VkDevice m_Device = VK_NULL_HANDLE;
	/** Device queues are implicitly destroyed when the device is destroyed */
	VkQueue m_GraphicsQueue = VK_NULL_HANDLE;
	VkQueue m_PresentQueue = VK_NULL_HANDLE;

	VkSampleCountFlagBits m_MsaaSamples = VK_SAMPLE_COUNT_1_BIT;
	VkImage m_ColorImage = VK_NULL_HANDLE;
	VkDeviceMemory m_ColorImageMemory = VK_NULL_HANDLE;
	VkImageView m_ColorImageView = VK_NULL_HANDLE;

	VkSwapchainKHR m_SwapChain = VK_NULL_HANDLE;
	/** The images were created by the implementation for the swap chain and
	* they will be automatically cleaned up once the swap chain has been destroyed.
	*/
	std::vector<VkImage> m_SwapChainImages;
	std::vector<VkImageView> m_SwapChainImageViews;
	VkFormat m_SwapChainImageFormat = VK_FORMAT_UNDEFINED;
	VkExtent2D m_SwapChainExtent = { 0, 0 };

	VkRenderPass m_RenderPass = VK_NULL_HANDLE;
	VkPipelineLayout m_PipelineLayout = VK_NULL_HANDLE;

	enum GRAPHICS_PIPELINE_TYPE
	{
		GRAPHICS_PIPELINE_TYPE_FILL       = 0b1,
		GRAPHICS_PIPELINE_TYPE_WIREFRAME  = 0b10,
		GRAPHICS_PIPELINE_TYPE_POINT      = 0b100,
		GRAPHICS_PIPELINE_TYPE_FRONT_CULL = 0b1000,
		GRAPHICS_PIPELINE_TYPE_BACK_CULL  = 0b10000,
		GRAPHICS_PIPELINE_TYPE_NONE_CULL  = 0b100000,
	};

	std::unordered_map<int, const char *> m_GraphicsPipelinesDescription =
	{
		{ GRAPHICS_PIPELINE_TYPE_FILL | GRAPHICS_PIPELINE_TYPE_FRONT_CULL, "Fill & Front cull" },
		{ GRAPHICS_PIPELINE_TYPE_WIREFRAME | GRAPHICS_PIPELINE_TYPE_FRONT_CULL, "Wireframe & Front cull" },
		{ GRAPHICS_PIPELINE_TYPE_POINT | GRAPHICS_PIPELINE_TYPE_FRONT_CULL, "Point & Front cull" },

		{ GRAPHICS_PIPELINE_TYPE_FILL | GRAPHICS_PIPELINE_TYPE_BACK_CULL, "Fill & Back cull" },
		{ GRAPHICS_PIPELINE_TYPE_WIREFRAME | GRAPHICS_PIPELINE_TYPE_BACK_CULL, "Wireframe & Back cull" },
		{ GRAPHICS_PIPELINE_TYPE_POINT | GRAPHICS_PIPELINE_TYPE_BACK_CULL, "Point & Back cull" },

		{ GRAPHICS_PIPELINE_TYPE_FILL | GRAPHICS_PIPELINE_TYPE_NONE_CULL, "Fill & None cull" },
		{ GRAPHICS_PIPELINE_TYPE_WIREFRAME | GRAPHICS_PIPELINE_TYPE_NONE_CULL, "Wireframe & None cull" },
		{ GRAPHICS_PIPELINE_TYPE_POINT | GRAPHICS_PIPELINE_TYPE_NONE_CULL, "Point & None cull" }
	};

	std::unordered_map<int, VkPipeline> m_GraphicsPipelines;
	int m_GraphicsPipelineDisplayMode = GRAPHICS_PIPELINE_TYPE_FILL;
	int m_GraphicsPipelineCullMode = GRAPHICS_PIPELINE_TYPE_NONE_CULL;

	VkImage m_DepthImage = VK_NULL_HANDLE;
	VkDeviceMemory m_DepthImageMemory = VK_NULL_HANDLE;
	VkImageView m_DepthImageView = VK_NULL_HANDLE;

	std::vector<VkFramebuffer> m_SwapChainFramebuffers;

	VkCommandPool m_CommandPool = VK_NULL_HANDLE;
	/** Command buffers will be automatically freed when their command pool is destroyed. */
	std::vector<VkCommandBuffer> m_DrawingCommandBuffers;

	const int m_MaxFramesInFlights = 2;
	std::vector<VkSemaphore> m_ImageAvailableSemaphores;
	std::vector<VkSemaphore> m_RenderFinishedSemaphores;
	std::vector<VkFence> m_InFlightFences;
	size_t m_CurrentFrame = 0;

protected: /** Mesh */
	struct Vertex
	{
		glm::vec3 Position;
		glm::vec3 Color;
		glm::vec3 Normal;
		glm::vec2 TexCoord;

		static VkVertexInputBindingDescription GetBindingDescription();
		static std::array<VkVertexInputAttributeDescription, 4> GetAttributeDescription();
	};

	struct VertexHash
	{
		size_t operator()(const Vertex & Rhs) const;
	};

	struct VertexEqual
	{
		bool operator()(const Vertex & Lhs, const Vertex & Rhs) const;
	};

	const std::string m_ModelPath = "Models/chalet.obj";
	std::vector<Vertex> m_Vertices;
	std::vector<uint32_t> m_Indices;

	size_t m_VertexNum = 0;
	size_t m_FacetNum = 0;

	VkBuffer m_VertexBuffer = VK_NULL_HANDLE;
	VkDeviceMemory m_VertexBufferMemory = VK_NULL_HANDLE;
	VkBuffer m_IndexBuffer = VK_NULL_HANDLE;
	VkDeviceMemory m_IndexBufferMemory = VK_NULL_HANDLE;

protected: /** UBO */
	struct MvpUniformBufferObject
	{
		alignas(16) glm::mat4 Model;
		alignas(16) glm::mat4 View;
		alignas(16) glm::mat4 Projection;
	};

	struct LightUniformBufferObject
	{
		alignas(16) glm::vec3 LightPosition;
		alignas(16) glm::vec3 LightColor;
	};

	VkDescriptorSetLayout m_DescriptorSetLayout = VK_NULL_HANDLE;
	std::vector<VkBuffer> m_MvpUniformBuffers;
	std::vector<VkDeviceMemory> m_MvpUniformBufferMemories;
	std::vector<VkBuffer> m_LightUniformBuffers;
	std::vector<VkDeviceMemory> m_LightUniformBufferMemories;
	VkDescriptorPool m_DescriptorPool = VK_NULL_HANDLE;
	/** Descriptor sets will be automatically freed when the descriptor pool is destroyed. */
	std::vector<VkDescriptorSet> m_DescriptorSets;

protected: /** Texture */
	const std::string m_TexturePath = "Textures/chalet.jpg";
	uint32_t m_MipLevels = 0;
	VkImage m_TextureImage = VK_NULL_HANDLE;
	VkDeviceMemory m_TextureImageMemory = VK_NULL_HANDLE;
	VkImageView m_TextureImageView = VK_NULL_HANDLE;
	VkSampler m_TextureSamler = VK_NULL_HANDLE;

protected: /** Camera */
	Camera m_Camera;
	int m_MouseButton = -1;
	int m_MouseAction = -1;
};

NAMESPACE_END